Clusters:
  {{ cluster_id }}:
    SystemRootToken: "{{ system_root_token }}"
    ManagementToken: "{{ management_token }}"
    Collections:
      BlobSigningKey: "{{ blob_signing_key }}"
    PostgreSQL:
      Connection:
        host: "{{ postgres_host }}"
        user: "{{ postgres_user }}"
        password: "{{ postgres_password }}"
        dbname: "{{ postgres_database_name }}"
    Login:
      LDAP:
        Enable: true
        URL: "{{ ldap_server }}"
        StartTLS: false
        InsecureTLS: true
        # Strip the @domain part if a user supplies an email-style
        # username with this domain. If "*", strip any user-provided
        # domain. If "", never strip the domain part. Example:
        # "example.com"
        StripDomain: "*"

        # The LDAP attribute to filter on when looking up a username
        # (after applying StripDomain and AppendDomain).
        SearchAttribute: "{{ ldap_search_attribute }}"

        # Bind with this username (DN or UPN) and password when
        # looking up the user record.
        #
        # Example user: "cn=admin,dc=example,dc=com"
        SearchBindUser: "{{ ldap_search_bind_user }}"
        SearchBindPassword: "{{ ldap_search_bind_password }}"

        # Directory base for username lookup. Example:
        # "ou=Users,dc=example,dc=com"
        SearchBase: "{{ ldap_search_base }}"

        # Additional filters to apply when looking up users' LDAP
        # entries. This can be used to restrict access to a subset of
        # LDAP users, or to disambiguate users from other directory
        # entries that have the SearchAttribute present.
        #
        # Special characters in assertion values must be escaped (see
        # RFC4515).
        #
        # Example: "(objectClass=person)"
        # SearchFilters: ""

        # LDAP attribute to use as the user's email address.
        #
        # Important: This must not be an attribute whose value can be
        # edited in the directory by the users themselves. Otherwise,
        # users can take over other users' Arvados accounts trivially
        # (email address is the primary key for Arvados accounts.)
        EmailAttribute: mail

        # LDAP attribute to use as the preferred Arvados username. If
        # no value is found (or this config is empty) the username
        # originally supplied by the user will be used.
        UsernameAttribute: "{{ ldap_username_attribute }}"
    Users:
      # The e-mail address of the user you would like to become marked as an admin
      # user on their first login.
      AutoAdminUserWithEmail: "{{ auto_admin_user }}"
      AnonymousUserToken: "{{ anonymous_user_token }}"
    Services:
      Controller:
        ExternalURL: "{{ controller_external_url }}"
        InternalURLs:
          "{{ controller_internal_url }}": {}
      RailsAPI:
      # Does not have an ExternalURL
        InternalURLs:
          "{{ rails_internal_url }}": {}
      Keepstore:
        # No ExternalURL because they are only accessed by the internal subnet.
        InternalURLs:
          "{{ keep_internal_url1 }}": {}
      Keepproxy:
        ExternalURL: "{{ keepproxy_external_url }}"
        InternalURLs:
          "{{ keepproxy_internal_url1 }}": {}
          "{{ keepproxy_internal_url2 }}": {}
      WebDAVDownload:
        ExternalURL: "{{ download_external_url }}"
      WebDAV:
        ExternalURL: "{{ collections_external_url }}"
        InternalURLs:
          "{{ collections_internal_url1 }}": {}
          "{{ collections_internal_url2 }}": {}
      Websocket:
        InternalURLs:
          "{{ ws_internal_url }}": {}
        ExternalURL: "{{ ws_external_url }}"
      Workbench1:
        ExternalURL: "{{ workbench1_external_url }}"
      Workbench2:
        ExternalURL: "{{ workbench2_external_url }}"
      DispatchCloud:
        InternalURLs:
          "{{ dispatch_cloud_internal_url }}": {}
      GitSSH:
        ExternalURL: "{{ ssh_git_external_url }}"
      GitHTTP:
        ExternalURL: "{{ http_git_external_url }}"
        InternalURLs:
          "{{ http_git_internal_url }}": {}
    Git:
      GitCommand: /var/lib/arvados/git/gitolite/src/gitolite-shell
      GitoliteHome: /var/lib/arvados/git
      Repositories: /var/lib/arvados/git/repositories
    Containers:
      CloudVMs:
        # BootProbeCommand is a shell command that succeeds when an instance is ready for service
        BootProbeCommand: "sudo systemctl status docker"
        ImageID: "{{ cloud_image_id }}"
        Driver: ec2
        DriverParameters:
          # If you are not using an IAM role for authentication, specify access
          # credentials here. Otherwise, omit or set AccessKeyID and
          # SecretAccessKey to an empty value.
          AccessKeyID: "{{ cloud_access_key_id }}"
          SecretAccessKey: "{{ cloud_secret_key }}"
          
          SecurityGroupIDs:
          - "{{ security_group_id }}"
          SubnetID: "{{ subnet_id }}"
          Region: "{{ aws_region }}"
          EBSVolumeType: gp2
          AdminUsername: arvados
      DispatchPrivateKey: "{{ cloud_dispatch_private_key }}"
    InstanceTypes:
      t3xl:
        ProviderType: t3.xlarge
        VCPUs: 4
        RAM: 16GiB
        IncludedScratch: 64GB
        Price: 0.62
      t32x:
        ProviderType: t3.2xlarge
        VCPUs: 8
        RAM: 32GiB
        IncludedScratch: 64GB
        Price: 1.23
    Workbench:
      SecretKeyBase: "{{ workbench_secret_key }}"
    Volumes:
      {{ cluster_id }}-nyw5e-000000000000000:
        Driver: Directory
        DriverParameters:
          # The directory that will be used as the backing store.
          Root: "{{ keep_directory }}"

